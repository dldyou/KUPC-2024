#let I_desc = (
    (
        (
            [- 모든 수에 $A_i$를 더하고 K로 나머지를 취하는 과정을 빠르게 계산해야 합니다.],
            [- 결국 K로 나머지를 취하기 때문에 $A_i mod K$를 더하고 K로 나머지를 취한다고 볼 수 있습니다.],
            [- 따라서 K보다 작은 수를 더하고 나머지를 취하게 됩니다.],
        ),
        (
            [- $A_i mod K$를 더했을 때, 구간으로 나눠 생각해봅시다.],
            [$1$. 원소가 $2K$와 같거나 클 때, $K$보다 작은 원소에 $K$보다 작은 수를 더했으므로 이 구간에 원소가 없습니다.],
            [$2$. 원소가 $2K$보다 작고 $K$와 같거나 클 때, 원소에서 $K$를 빼야합니다.],
            [$3$. 원소가 $K$보다 작을 때, 가만히 두면 됩니다.],
            [- 이때 2번 구간의 모든 원소는 $A_i mod K$보다 작아지지만, 3번 구간의 모든 원소는 $A_i mod K$보다 크거나 같아집니다.],
            [- 즉 최댓값은 K보다 작은 구간에 생깁니다.],
        ),
        (
            [- 따라서 구하고자 하는 값은 K보다 작은 구간의 최댓값입니다.],
            [- 순서를 바꿔 $K minus A_i mod K$보다 작은 수 중 최댓값을 구한 뒤 $A_i mod K$를 더해주면 됩니다.], 
            [- 이는 이분탐색으로 계산할 수 있습니다.],
            [- 이 방법을 반복해서 수행하면 아래와 같은 결과가 나옵니다.],
            [$(infinity times K - A_1-A_2-...-A_i)  mod K$보다 작은 수 중 최댓값을 구한 뒤, $"("$최댓값 $+ A_1+A_2+...+A_i")" mod K$를 하면 $i$번째 시뮬레이션의 결과가 됩니다.],
        ),
        (
            [- 정렬한 뒤 시뮬레이션마다 이분탐색을 수행했으므로 시간복잡도는 $cal(O)(N log N +T log N)$가 됩니다.],
            linebreak(),
            linebreak(),
            [- 시간복잡도를 유지한 상태로 삽입연산과 삭제연산을 수행할 수 있습니다. 어떻게 해야 할까요?], 
        ),
    ),
)
